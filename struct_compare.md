# 課題２

### 何が起きているか
トリックの前はh1とh2のメモリ領域は完全に一致しているが、トリック後はメンバの値は同じにも関わらず、メモリ領域が異なっている。

### 構造体を比較する際になぜメンバを逐次比較するべきか
パディング領域に入っている値が異なる可能性がある。構造体において、パディング領域にどんな値が入っているのかは重要でないので、構造体全体で比較するのではなく、メンバを逐次比較するべきである。


### trickの細工
bの後に３バイトのパディングがある。ここの値が書き換わっていると考えられる。実際、トリック後のh1, h2に対して、
```c
printf("%s\n", (!memcmp(&h1.a,&h2.a,8))?"true":"false");
printf("%s\n", (!memcmp(&h1.b,&h2.b,4))?"true":"false");
printf("%s\n", (!memcmp(&h1.c,&h2.c,8))?"true":"false");
printf("%s\n", (!memcmp(&h1,&h2,sizeof(Obj)))?"true":"false");
```
を実行すると、bメンバのところだけfalseと出力される。
次に実際どんな値がパディングの領域に入っているのか確認するために、下のコードを追加して実行する。
```c
char *p_1 = &h1.b;
char *p_2 = &h2.b;
for (int i = 0; i < 3; i++) {
    printf("%c, %c\n", *(p_1 + i + 1), *(p_2 + i));
}
```
すると、
```
, c
, h
, e
```
のように出力されるので、トリックによってh2.bのパディング領域に、c, h, eが格納されているとわかる。